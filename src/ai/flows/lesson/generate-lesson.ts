
'use server';
/**
 * @fileOverview This file defines the orchestrator flow for generating a complete lesson.
 *
 * This flow coordinates multiple sub-flows to perform a sequence of tasks:
 * 1. Search for relevant sources based on a topic and phase.
 * 2. Synthesize a structured lesson from the found sources.
 * 3. Validate the synthesized lesson for quality and accuracy.
 * 4. Generate a quiz for the lesson content.
 * The flow then returns a comprehensive data object, ready for the client to process and save.
 *
 * @exports generateLesson - The main orchestrator function.
 */

import { z } from 'zod';
import { searchSources } from './search-sources';
import { synthesizeLesson } from './synthesize-lesson';
import { validateLesson } from './validate-lesson';
import { generateQuizForLesson } from '../generate-quizzes-for-knowledge-assessment';
import { 
  SynthesizeLessonOutputSchema, 
  ValidateLessonOutputSchema, 
  GenerateQuizForLessonOutputSchema 
} from './types';


const GenerateLessonInputSchema = z.object({
  topic: z.string().describe('The topic of study (e.g., "React Hooks", "Quantum Physics").'),
  phase: z.string().describe('The learning phase (e.g., "Beginner", "Intermediate", "Advanced").'),
  lessonId: z.string().describe('The Firestore ID of the lesson document to update.'), // Kept for quiz generation
});

// The final output schema, combining all generated data.
const GenerateLessonOutputSchema = z.object({
  lesson: SynthesizeLessonOutputSchema,
  validation: ValidateLessonOutputSchema,
  quiz: GenerateQuizForLessonOutputSchema,
});

export async function generateLesson(input: z.infer<typeof GenerateLessonInputSchema>): Promise<z.infer<typeof GenerateLessonOutputSchema>> {
  const { topic, phase, lessonId } = input;
    
  try {
    // Step 1: Search for sources
    const searchResult = await searchSources({ topic, phase });
    if (!searchResult || !searchResult.sources || searchResult.sources.length === 0) {
      throw new Error('Could not find any relevant sources for the topic.');
    }

    // Step 2: Synthesize the lesson from the sources
    const lessonDraft = await synthesizeLesson({
      topic,
      phase,
      sources: searchResult.sources,
    });

    // Step 2.5: Comprehensive validation before proceeding
    // This now checks the content generated by our own post-processing logic
    if (!lessonDraft || typeof lessonDraft.content !== 'string' || lessonDraft.content.trim().length < 100) {
        throw new Error('AI failed to generate valid lesson content. The draft is empty or too short.');
    }

    // Step 3: Validate the synthesized lesson using AI
    const validationResult = await validateLesson({ lessonDraft });

    // CRITICAL FIX: Check for the existence of validationResult itself before accessing its properties.
    if (!validationResult || !validationResult.valid) {
      const issues = validationResult?.issues ? JSON.stringify(validationResult.issues) : "No validation result was returned from the AI.";
      throw new Error(`Lesson validation failed. Issues: ${issues}`);
    }

    // Step 4: Generate Quiz
    const quizResult = await generateQuizForLesson({
        lesson_id: lessonId,
        lesson_content: lessonDraft.content,
    });

    // Return all data to the client for saving.
    return {
      lesson: lessonDraft,
      validation: validationResult,
      quiz: quizResult,
    };
  } catch (error: any) {
    // This flow can't write to Firestore, but we log the error on the server.
    // The client will handle user-facing errors.
    throw error;
  }
}
